; We use the rosette/safe language to enable symbolic execution
; We use the sweet-exp adapter to enable infix syntax when we write logical formulas
#lang sweet-exp rosette/safe

(require rosette/lib/synthax
         syntax/parse/define
         "truth-tables.rkt"
         "3vl-verification.rkt"
         (for-syntax
           racket/syntax
           syntax/to-string))

(define-syntax-parser verify-is-true
  [(_ (name:id arg ...) body)
   #`(begin
       (define (name arg ...) body)
       (module+ test
         (let () ; we use let to hide the following definitions from the outer scope
           (define result
             (verify-with-tvl-args (name arg ...)))
           (define cex
             (begin
               (if (sat? result)
                 (model result)
                 #f)))
           (define msg
             (if (sat? result)
               (format
                 #,(format "~a is falsified by the valuation ~~a" (syntax->string #'(name)))
                 cex)
               #f))
           (check-true (unsat? result) msg))))])

;; Figure 18.3

; We will require the dimp-from-mimp-test module in the test module, so we need to declare it first:
(module+ dimp-from-mimp-test
  (require rackunit))

(module+ test
  ; We use the rackunit testing framework
  (require rackunit))

(verify-is-true (eq-18.3.1 p)
    (eq?
      (¬ (¬ p))
      p))

(verify-is-true (eq-18.3.2 p q)
    (eq?
      {p ∨ q}
      (¬ {(¬ p) ∧ (¬ q)})))

(verify-is-true (eq-18.3.3 p q)
    (eq?
      {p ∧ q}
      (¬ {(¬ p) ∨ (¬ q)})))

(verify-is-true (eq-18.3.4 a b)
    (eq?
      {a ⊃ b}
      {(¬ a) ∨ b}))

(verify-is-true (eq-18.3.5 p)
    (eq?
      {p ⊃ 'f}
      (¬ p)))

(verify-is-true (eq-18.3.6.1 p q)
    (eq?
      {p ≡ q}
      {{p ⊃ q} ∧ {q ⊃ p}}))
(verify-is-true (eq-18.3.6.2 p q)
    (eq?
      {p ≡ q}
      {{(¬ p) ∨ q} ∧ {p ∨ (¬ q)}}))

(verify-is-true (eq-18.3.7.1 p q)
    (eq?
      {p ⇒ q}
      {(◇ p) ⊃ q}))
(verify-is-true (eq-18.3.7.2 p q)
    (eq?
      {p ⇒ q}
      {(□ (¬ p)) ∨ q}))

(verify-is-true (eq-18.3.8 p q)
    (eq?
      {p ⇔ q}
      {{p ⇒ q} ∧ {q ⇒ p}}))

(verify-is-true (eq-18.3.9.1 p)
    (eq?
      (□ p)
      (¬ (◇ (¬ p)))))
(verify-is-true (eq-18.3.9.2 p)
    (eq?
      (□ p)
      {(¬ p) ⇒ 'f}))

(verify-is-true (eq-18.3.10.1 p)
    (eq?
      (◇ p)
      (¬ (□ (¬ p)))))
(verify-is-true (eq-18.3.10.2 p)
    (eq?
      (◇ p)
      (¬ {p ⇒ 'f})))
(verify-is-true (eq-18.3.10.3 p)
    (eq?
      (◇ p)
      {{p ⇒ 'f} ⇒ 'f}))

(verify-is-true (eq-18.3.11.1 p)
    (eq?
      (B p)
      (◇ {p ∧ (¬ p)})))
(verify-is-true (eq-18.3.11.2 p)
    (eq?
      (B p)
      {(◇ p) ∧ (◇ (¬ p))}))
(verify-is-true (eq-18.3.11.3 p)
    (eq?
      (B p)
      {(◇ p) ∧ (¬ (□ p))}))

(verify-is-true (eq-18.3.12 p)
    (eq?
      (□ (◇ p))
      (◇ p)))

(verify-is-true (eq-18.3.13 p q)
    (eq?
      (◇ {p ⇒ q})
      {(◇ p) ⇒ (◇ q)}))

(verify-is-true (eq-18.3.13.1 p q)
    (eq?
      (□ {p ∧ q})
      {(□ p) ∧ (□ q)}))
(verify-is-true (eq-18.3.13.2 p q)
    (eq?
      (□ {p ∨ q})
      {(□ p) ∨ (□ q)}))
(verify-is-true (eq-18.3.13.3 p q)
    (eq?
      (◇ {p ∧ q})
      {(◇ p) ∧ (◇ q)}))
(verify-is-true (eq-18.3.13.4 p q)
    (eq?
      (◇ {p ∨ q})
      {(◇ p) ∨ (◇ q)}))

(verify-is-true (eq-18.2.7.1 p q)
    (eq?
      {p ⊃ q}
      {(¬ q) ⊃ (¬ p)}))

(verify-is-true (eq-18.4.12.1 p q r)
    (eq?
      {p ⊃ {q ⊃ r}}
      {{p ∧ q} ⊃ r}))
(verify-is-true (eq-18.4.12.2 p q r)
    (eq?
      {p ⇒ {q ⇒ r}}
      {{p ∧ q} ⇒ r}))

;; 18.4.3

(verify-is-true (my-eq-1 p q)
    (eq?
      (designated-value? {p ∧ q})
      (and (designated-value? p) (designated-value? q))))

(verify-is-true (my-eq-2 p q)
    (eq?
      (designated-value? {p ⇒ q})
      (=> (designated-value? p) (designated-value? q))))

(verify-is-true (my-eq-3 a p q)
    (eq?
      (designated-value? {a ⇒ {p ∧ q}})
      (and (designated-value? {a ⇒ p}) (designated-value? {a ⇒ q}))))

;; Now we check whether we can construct ⊃ from ⇒ and other modalities using an expression of fixed maximum depth

(module+ dimp-from-mimp-test
  (define-grammar (dimp-and-modalities p q)
                  [expr
                    (choose
                      p q 'f
                      {(expr) ⇒ (expr)}
                      (¬ (expr)) ; we also throw in negation, which does not seem to help
                      (◇ (expr))
                      (□ (expr)))])

  (define (my-mimp p q)
    (dimp-and-modalities p q #:depth 4))

  (define (check-is-mimp expr p q)
    (assert
      (eq?
        (expr p q)
        (⊃ p q))))

  (define-symbolic p/bv q/bv (bitvector 2))

  (define dimp-from-mimp-solution
    (synthesize
      #:forall (list p/bv q/bv)
      #:guarantee (check-is-mimp my-mimp (bv-to-3 p/bv) (bv-to-3 q/bv))))

  ;; We cannot construct ⊃ using expression generated by the grammar with depth at most 4:
  (check-false (sat? dimp-from-mimp-solution)))

(module+ test
  (require (submod ".." dimp-from-mimp-test)))
